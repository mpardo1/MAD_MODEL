ylab("Counts") +
ggtitle("Vector dynamics")+
scale_color_manual(name = "",
labels = c("Larva", "Adult mosquito", "Adult handling mosquito"),
values=c('#FF00F6','#FF2C00','#FF2C23'))+
theme_bw()
ggplot(ode) +
geom_line(aes(time,y3))
colnames(ode) <- c("time","L","A","Ah")
head(ode)
omega_t = 1
trueSD = 100
# We create a vector with the constant parameters.
parms = c(f,K,H,omega_t)
# We set the initial conditions to zero.
Y <- c(y1 = 100.0, y2 = 0.0, y3 = 0.0)
times <- seq(min_t,max_t, 1)
out2 <- ode(Y, times, func = "derivs",
parms = parms, dllname = "model_vec_cte",
initfunc = "initmod", nout = 1,
outnames = "Sum")
ode2 <- data.frame(out2)
ode2$Sum <- NULL
df_plot2 <- reshape2::melt(ode2, id.vars = c("time"))
ggplot(df_plot2,aes(time, value))  +
geom_line(aes( colour = variable)) +
ylab("Counts") +
ggtitle("Vector dynamics")+
scale_color_manual(name = "",
labels = c("Larva", "Adult mosquito", "Adult handling mosquito"),
values=c('#FF00F6','#FF2C00','#FF2C23'))+
theme_bw()
ggplot(ode2) +
geom_line(aes(time,y3))
colnames(ode2) <- c("time","L","A","Ah")
sum1 <- ode$A + ode$Ah
sum2 <- ode2$A + ode$Ah
head(ode2)
diff_df <- abs(sum1 - sum2)
saveRDS(ode, file = "~/MAD_MODEL/VECTOR_MODEL/Code/PARAM_ESTIMA/ode_pseudo.rds")
# Función de c que corre la ODE -------------------------------------------
# Esta función está adaptada para su uso con el paquete deSolve, el estándar en
# R para las ODE
Path = "~/MAD_MODEL/VECTOR_MODEL/Code/PARAM_ESTIMA/"
# Path = paste(PC,Path, sep="")
setwd(Path)
system("R CMD SHLIB model_vec_cte.c")
dyn.load("model_vec_cte.so")
# Función que calcula la loglikelihood del modelo ----------------------------------
# Esta será la función a optimizar
ll_ode <- function(x, # Params
y, # datos
devs){ #desviaciones estándar para calcular la loglikelihood
if(x[1] <=  0){
res = -86829146000
}else{
pars <- c(f = f,K = K,H = H,omega = x[1])
cat("Pars:",pars, "\n")
population <- c(y1 = 100.0, y2 = 0.0, y3 = 0.0)
z <- ode(y=population,
times = 0:nrow(y), func = "derivs",
dllname = "model_vec_cte" , parms = pars,
initfunc = "initmod")
#Aquí corre el ODE
colnames(z)[2:4] <- c("L", "A", "Ah")
z <- as.data.frame(z)
z <- z[-1, ]
L <- y$L
A <- y$A
Ah <- y$Ah
res <- sum(dnorm(L, mean = z$L, sd = devs[1], log = T))  +
sum(dnorm(A, mean = z$A , sd = devs[1], log = T))  +
sum(dnorm(Ah, mean = z$Ah, sd = devs[1], log = T))
}
cat("res:",res, "\n")
return(res)
}
# Carga datos -------------------------------------------------------------
# Pseudo Data to check the oprimization method.
ob_data <- readRDS(file = "~/MAD_MODEL/VECTOR_MODEL/Code/PARAM_ESTIMA/ode_pseudo.rds")
colnames(ob_data) <- c("time", "L", "A", "Ah")
l <- nrow(ob_data)
ob_data$L <- ob_data$L + rnorm(l,0,trueSD)
ob_data$A <- ob_data$A + rnorm(l,0,trueSD)
ob_data$Ah <- ob_data$Ah + rnorm(l,0,trueSD)
head(ob_data)
df_plot <- reshape2::melt(ob_data, id.vars = c("time"))
ggplot(df_plot,aes(time, value))  +
geom_line(aes( colour = variable)) +
ylab("Counts") +
ggtitle("Vector dynamics")+
scale_color_manual(name = "",
labels = c("Larva", "Adult mosquito", "Adult handling mosquito"),
values=c('#FF00F6','#FF2C00','2F822B'))+
theme_bw()
# f_inicio <- as.Date("2021-05-14")
# f_fin <- as.Date("2021-06-12")
#
# n_inicio <- which(data$FECHA == f_inicio)
# n_fin <- which(data$FECHA == f_fin)
n_inicio <- 1
n_fin <- max(ob_data$time)
input2 <- ob_data[n_inicio:n_fin, ]
# Estima desviación estandar de cada serie --------------------------------
# Esto nos permite asignar una likelihood al conjunto del modelo, considerando
# las series independientes.
devs <- c()
spl <- input2$A + input2$Ah
fit <- smooth.spline(x = 1:nrow(input2), y = spl, df = 4)
devs[1] <- sd(spl - predict(fit)$y)
y <- ode
# (x, # vector con los parámetros
#   forcs_mat, # forzamientos para el solver de la ode
#   y, # datos
#   devs)
likelyhood <- function(x){
return(ll_ode(x,y,devs))
}
x <- seq(1, 500, by=.05)
slopelikelihoods <- lapply(x,likelyhood)
slopelikelihoods_num <- as.numeric(unlist(slopelikelihoods))
slopelikelihoods_num <- slopelikelihoods_num - trunc(slopelikelihoods_num)
plot (x, slopelikelihoods , type="l", xlab = "values of omega", ylab = "Log likelihood")# Forzamientos ------------------------------------------------------------
plot (x, slopelikelihoods , type="l", xlab = "values of omega", ylab = "Log likelihood")# Forzamientos ------------------------------------------------------------
ll_ode <- function(x, # Params
y, # datos
devs){ #desviaciones estándar para calcular la loglikelihood
if(x[1] <=  0){
res = -86829146000
}else{
pars <- c(f = f,K = K,H = H,omega = x[1])
cat("Pars:",pars, "\n")
population <- c(y1 = 100.0, y2 = 0.0, y3 = 0.0)
z <- ode(y=population,
times = 0:nrow(y), func = "derivs",
dllname = "model_vec_cte" , parms = pars,
initfunc = "initmod")
#Aquí corre el ODE
colnames(z)[2:4] <- c("L", "A", "Ah")
z <- as.data.frame(z)
z <- z[-1, ]
L <- y$L
A <- y$A
Ah <- y$Ah
res <- sum(dnorm(L, mean = z$L, sd = 1, log = T))  +
sum(dnorm(A, mean = z$A , sd = 1, log = T))  +
sum(dnorm(Ah, mean = z$Ah, sd = 1, log = T))
}
cat("res:",res, "\n")
return(res)
}
# Carga datos -------------------------------------------------------------
# Pseudo Data to check the oprimization method.
ob_data <- readRDS(file = "~/MAD_MODEL/VECTOR_MODEL/Code/PARAM_ESTIMA/ode_pseudo.rds")
colnames(ob_data) <- c("time", "L", "A", "Ah")
l <- nrow(ob_data)
ob_data$L <- ob_data$L + rnorm(l,0,trueSD)
ob_data$A <- ob_data$A + rnorm(l,0,trueSD)
ob_data$Ah <- ob_data$Ah + rnorm(l,0,trueSD)
head(ob_data)
df_plot <- reshape2::melt(ob_data, id.vars = c("time"))
ggplot(df_plot,aes(time, value))  +
geom_line(aes( colour = variable)) +
ylab("Counts") +
ggtitle("Vector dynamics")+
scale_color_manual(name = "",
labels = c("Larva", "Adult mosquito", "Adult handling mosquito"),
values=c('#FF00F6','#FF2C00','2F822B'))+
theme_bw()
n_inicio <- 1
n_fin <- max(ob_data$time)
input2 <- ob_data[n_inicio:n_fin, ]
devs <- c()
spl <- input2$A + input2$Ah
fit <- smooth.spline(x = 1:nrow(input2), y = spl, df = 4)
devs[1] <- sd(spl - predict(fit)$y)
y <- ode
# (x, # vector con los parámetros
#   forcs_mat, # forzamientos para el solver de la ode
#   y, # datos
#   devs)
likelyhood <- function(x){
return(ll_ode(x,y,devs))
}
x <- seq(1, 500, by=.05)
slopelikelihoods <- lapply(x,likelyhood)
slopelikelihoods_num <- as.numeric(unlist(slopelikelihoods))
slopelikelihoods_num <- slopelikelihoods_num - trunc(slopelikelihoods_num)
plot (x, slopelikelihoods , type="l", xlab = "values of omega", ylab = "Log likelihood")# Forzamientos ------------------------------------------------------------
ll_ode <- function(x, # Params
y, # datos
devs){ #desviaciones estándar para calcular la loglikelihood
# if(x[1] <=  0){
if(1 ==  0){
res = -86829146000
}else{
pars <- c(f = f,K = K,H = H,omega = x[1])
cat("Pars:",pars, "\n")
population <- c(y1 = 100.0, y2 = 0.0, y3 = 0.0)
z <- ode(y=population,
times = 0:nrow(y), func = "derivs",
dllname = "model_vec_cte" , parms = pars,
initfunc = "initmod")
#Aquí corre el ODE
colnames(z)[2:4] <- c("L", "A", "Ah")
z <- as.data.frame(z)
z <- z[-1, ]
L <- y$L
A <- y$A
Ah <- y$Ah
res <- sum(dnorm(L, mean = z$L, sd = 1, log = T))  +
sum(dnorm(A, mean = z$A , sd = 1, log = T))  +
sum(dnorm(Ah, mean = z$Ah, sd = 1, log = T))
}
cat("res:",res, "\n")
return(res)
}
# Carga datos -------------------------------------------------------------
# Pseudo Data to check the oprimization method.
ob_data <- readRDS(file = "~/MAD_MODEL/VECTOR_MODEL/Code/PARAM_ESTIMA/ode_pseudo.rds")
colnames(ob_data) <- c("time", "L", "A", "Ah")
l <- nrow(ob_data)
ob_data$L <- ob_data$L + rnorm(l,0,trueSD)
ob_data$A <- ob_data$A + rnorm(l,0,trueSD)
ob_data$Ah <- ob_data$Ah + rnorm(l,0,trueSD)
head(ob_data)
df_plot <- reshape2::melt(ob_data, id.vars = c("time"))
ggplot(df_plot,aes(time, value))  +
geom_line(aes( colour = variable)) +
ylab("Counts") +
ggtitle("Vector dynamics")+
scale_color_manual(name = "",
labels = c("Larva", "Adult mosquito", "Adult handling mosquito"),
values=c('#FF00F6','#FF2C00','2F822B'))+
theme_bw()
n_inicio <- 1
n_fin <- max(ob_data$time)
input2 <- ob_data[n_inicio:n_fin, ]
devs <- c()
spl <- input2$A + input2$Ah
fit <- smooth.spline(x = 1:nrow(input2), y = spl, df = 4)
devs[1] <- sd(spl - predict(fit)$y)
y <- ode
# (x, # vector con los parámetros
#   forcs_mat, # forzamientos para el solver de la ode
#   y, # datos
#   devs)
likelyhood <- function(x){
return(ll_ode(x,y,devs))
}
x <- seq(1, 500, by=.05)
slopelikelihoods <- lapply(x,likelyhood)
slopelikelihoods_num <- as.numeric(unlist(slopelikelihoods))
slopelikelihoods_num <- slopelikelihoods_num - trunc(slopelikelihoods_num)
plot (x, slopelikelihoods , type="l", xlab = "values of omega", ylab = "Log likelihood")# Forzamientos ------------------------------------------------------------
plot (x, slopelikelihoods , type="l", xlab = "values of omega", ylab = "Log likelihood")# Forzamientos ------------------------------------------------------------
rm(list = ls())
library("parallel")
library("tidyverse")
library("deSolve")
library("coda")
###############   ODE INTEGRATION   ##################
Path = "~/MAD_MODEL/VECTOR_MODEL/Code/PARAM_ESTIMA/"
setwd(Path)
system("R CMD SHLIB model_vec_cte.c")
dyn.load("model_vec_cte.so")
f = 200
K = 250000
H = 160000
omega_t = 0.1
trueSD = 1
# We create a vector with the constant parameters.
parms = c(f,K,H, omega_t)
# We set the initial conditions to cero.
Y <- c(y1 = 100.0, y2 = 0.0, y3 = 0.0)
min_t <- 1
max_t <- 365
times <- seq(min_t,max_t, 1)
out <- ode(Y, times, func = "derivs",
parms = parms, dllname = "model_vec_cte",
initfunc = "initmod", nout = 1,
outnames = "Sum")
ode <- data.frame(out)
ode$Sum <- NULL
saveRDS(ode, file = "~/MAD_MODEL/VECTOR_MODEL/Code/PARAM_ESTIMA/ode_pseudo.rds")
likelihood <- function(x) # forzamientos para el solver de la ode
{
if(x[1] <= 0 ){
print("Negative param")
res = -86829146000
}else{
pars <- c(f = f,K = K,H = H,omega = x[1]) # death rate group 2
sd <- x[2]
population <- c(y1 = 100.0, y2 = 0.0, y3 = 0.0) #Vector inicial para ODE
z <- ode(y=population,
times = 0:nrow(y), func = "derivs",
dllname = "model_vec_cte" , parms = pars,
initfunc = "initmod")
#Aquí corre el ODE
colnames(z)[2:4] <- c("L", "A", "Ah")
z <- as.data.frame(z)
z <- z[-1, ]
L <- y$L
A <- y$A
Ah <- y$Ah
res <- #cálculo de la loglikelihood en función de las desviaciones estándar
sum(dnorm((A+Ah), mean = (z$A + z$Ah), sd = sd, log = T))
}
# print("res:")
# print(res)
return(res)
}
# Pseudo Data to check the oprimization method.
ob_data <- readRDS(file = "~/MAD_MODEL/VECTOR_MODEL/Code/PARAM_ESTIMA/ode_pseudo.rds")
colnames(ob_data) <- c("time", "L", "A", "Ah")
l <- nrow(ob_data)
ob_data$L <- ob_data$L + rnorm(l,0,trueSD)
ob_data$A <- ob_data$A + rnorm(l,0,trueSD)
ob_data$Ah <- ob_data$Ah + rnorm(l,0,trueSD)
true1 = omega_t
y <- ob_data
# Prior distribution
prior = function(param){
a = param[1]
sd = param[2]
aprior = dnorm(a, sd=1,  log = T)
sdprior = dnorm(sd, sd=1,  log = T)
return(aprior+sdprior)
}
proposalfunction = function(param){
vec <- c(rnorm(1, mean = param[1], sd= 0.1)
,abs(rnorm(1,mean = param[2] ,sd = 0.1)))
return(vec)
}
slopevalues = function(x){return(likelihood(c(x, trueSD)))}
x <- seq(0.5, 7, by=.05)
slopelikelihoods = lapply(x, slopevalues )
plot (x, slopelikelihoods , type="l", xlab = "values of slope parameter a", ylab = "Log likelihood")
rm(list = ls())
library("parallel")
library("tidyverse")
library("deSolve")
library("coda")
###############   ODE INTEGRATION   ##################
Path = "~/MAD_MODEL/VECTOR_MODEL/Code/PARAM_ESTIMA/"
# Path = paste(PC,Path, sep="")
setwd(Path)
system("R CMD SHLIB model_vec_cte.c")
dyn.load("model_vec_cte.so")
f = 200
K = 250000
H = 160000
omega_t = 0.1
trueSD = 1
# We create a vector with the constant parameters.
parms = c(f,K,H, omega_t)
# We set the initial conditions to cero.
Y <- c(y1 = 100.0, y2 = 0.0, y3 = 0.0)
min_t <- 1
max_t <- 365
times <- seq(min_t,max_t, 1)
out <- ode(Y, times, func = "derivs",
parms = parms, dllname = "model_vec_cte",
initfunc = "initmod", nout = 1,
outnames = "Sum")
ode <- data.frame(out)
ode$Sum <- NULL
saveRDS(ode, file = "~/MAD_MODEL/VECTOR_MODEL/Code/PARAM_ESTIMA/ode_pseudo.rds")
likelihood <- function(x) # forzamientos para el solver de la ode
{
if(x[1] <= 0 ){
print("Negative param")
res = -86829146000
}else{
pars <- c(f = f,K = K,H = H,omega = x[1]) # death rate group 2
sd <- x[2]
population <- c(y1 = 100.0, y2 = 0.0, y3 = 0.0) #Vector inicial para ODE
z <- ode(y=population,
times = 0:nrow(y), func = "derivs",
dllname = "model_vec_cte" , parms = pars,
initfunc = "initmod")
#Aquí corre el ODE
colnames(z)[2:4] <- c("L", "A", "Ah")
z <- as.data.frame(z)
z <- z[-1, ]
L <- y$L
A <- y$A
Ah <- y$Ah
res <- #cálculo de la loglikelihood en función de las desviaciones estándar
sum(dnorm((A+Ah), mean = (z$A + z$Ah), sd = sd, log = T))
}
# print("res:")
# print(res)
return(res)
}
# Pseudo Data to check the oprimization method.
ob_data <- readRDS(file = "~/MAD_MODEL/VECTOR_MODEL/Code/PARAM_ESTIMA/ode_pseudo.rds")
colnames(ob_data) <- c("time", "L", "A", "Ah")
l <- nrow(ob_data)
ob_data$L <- ob_data$L + rnorm(l,0,trueSD)
ob_data$A <- ob_data$A + rnorm(l,0,trueSD)
ob_data$Ah <- ob_data$Ah + rnorm(l,0,trueSD)
true1 = omega_t
y <- ob_data
slopevalues = function(x){return(likelihood(c(x, trueSD)))}
x <- seq(0.5, 7, by=.05)
slopelikelihoods = lapply(x, slopevalues )
plot (x, slopelikelihoods , type="l", xlab = "values of slope parameter a", ylab = "Log likelihood")
likelihood <- function(x) # forzamientos para el solver de la ode
{
if(x[1] <= 0 ){
print("Negative param")
res = -86829146000
}else{
pars <- c(f = f,K = K,H = H,omega = x[1]) # death rate group 2
sd <- x[2]
population <- c(y1 = 100.0, y2 = 0.0, y3 = 0.0) #Vector inicial para ODE
z <- ode(y=population,
times = 0:nrow(y), func = "derivs",
dllname = "model_vec_cte" , parms = pars,
initfunc = "initmod")
#Aquí corre el ODE
colnames(z)[2:4] <- c("L", "A", "Ah")
z <- as.data.frame(z)
z <- z[-1, ]
L <- y$L
A <- y$A
Ah <- y$Ah
res <-  sum(dnorm(L, mean = z$L, sd = 1, log = T))  +
sum(dnorm(A, mean = z$A , sd = 1, log = T))  +
sum(dnorm(Ah, mean = z$Ah, sd = 1, log = T))  #cálculo de la loglikelihood en función de las desviaciones estándar
# sum(dnorm((A+Ah), mean = (z$A + z$Ah), sd = sd, log = T))
}
# print("res:")
# print(res)
return(res)
}
# Pseudo Data to check the oprimization method.
ob_data <- readRDS(file = "~/MAD_MODEL/VECTOR_MODEL/Code/PARAM_ESTIMA/ode_pseudo.rds")
colnames(ob_data) <- c("time", "L", "A", "Ah")
l <- nrow(ob_data)
ob_data$L <- ob_data$L + rnorm(l,0,trueSD)
ob_data$A <- ob_data$A + rnorm(l,0,trueSD)
ob_data$Ah <- ob_data$Ah + rnorm(l,0,trueSD)
true1 = omega_t
y <- ob_data
slopevalues = function(x){return(likelihood(c(x, trueSD)))}
x <- seq(0.5, 7, by=.05)
slopelikelihoods = lapply(x, slopevalues )
plot (x, slopelikelihoods , type="l", xlab = "values of slope parameter a", ylab = "Log likelihood")
omega_t = 04
omega_t = 4
trueSD = 1
# We create a vector with the constant parameters.
parms = c(f,K,H, omega_t)
# We set the initial conditions to cero.
Y <- c(y1 = 100.0, y2 = 0.0, y3 = 0.0)
min_t <- 1
max_t <- 365
times <- seq(min_t,max_t, 1)
out <- ode(Y, times, func = "derivs",
parms = parms, dllname = "model_vec_cte",
initfunc = "initmod", nout = 1,
outnames = "Sum")
ode <- data.frame(out)
ode$Sum <- NULL
saveRDS(ode, file = "~/MAD_MODEL/VECTOR_MODEL/Code/PARAM_ESTIMA/ode_pseudo.rds")
likelihood <- function(x) # forzamientos para el solver de la ode
{
if(x[1] <= 0 ){
print("Negative param")
res = -86829146000
}else{
pars <- c(f = f,K = K,H = H,omega = x[1]) # death rate group 2
sd <- x[2]
population <- c(y1 = 100.0, y2 = 0.0, y3 = 0.0) #Vector inicial para ODE
z <- ode(y=population,
times = 0:nrow(y), func = "derivs",
dllname = "model_vec_cte" , parms = pars,
initfunc = "initmod")
#Aquí corre el ODE
colnames(z)[2:4] <- c("L", "A", "Ah")
z <- as.data.frame(z)
z <- z[-1, ]
L <- y$L
A <- y$A
Ah <- y$Ah
res <-  sum(dnorm(L, mean = z$L, sd = 1, log = T))  +
sum(dnorm(A, mean = z$A , sd = 1, log = T))  +
sum(dnorm(Ah, mean = z$Ah, sd = 1, log = T))  #cálculo de la loglikelihood en función de las desviaciones estándar
# sum(dnorm((A+Ah), mean = (z$A + z$Ah), sd = sd, log = T))
}
# print("res:")
# print(res)
return(res)
}
# Pseudo Data to check the oprimization method.
ob_data <- readRDS(file = "~/MAD_MODEL/VECTOR_MODEL/Code/PARAM_ESTIMA/ode_pseudo.rds")
colnames(ob_data) <- c("time", "L", "A", "Ah")
l <- nrow(ob_data)
ob_data$L <- ob_data$L + rnorm(l,0,trueSD)
ob_data$A <- ob_data$A + rnorm(l,0,trueSD)
ob_data$Ah <- ob_data$Ah + rnorm(l,0,trueSD)
true1 = omega_t
y <- ob_data
slopevalues = function(x){return(likelihood(c(x, trueSD)))}
x <- seq(0.5, 7, by=.05)
slopelikelihoods = lapply(x, slopevalues )
plot (x, slopelikelihoods , type="l", xlab = "values of slope parameter a", ylab = "Log likelihood")
x <- seq(0.5, 100, by=.05)
slopelikelihoods = lapply(x, slopevalues )
plot (x, slopelikelihoods , type="l", xlab = "values of slope parameter a", ylab = "Log likelihood")
