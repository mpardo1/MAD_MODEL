df_deltaA_out <- data.frame(date = temp$date, deltaA = unlist(lapply(temp$mean_temp,delta_A)))
df_deltaA_out$time = as.numeric(df_deltaA_out$date - as.Date(min_date,"%Y-%m-%d") , units="days")
df_deltaA_out <- df_deltaA_out %>% filter( df_deltaA_out$time >= 0)
df_rho$time = as.numeric(df_rho$date - as.Date(min_date,"%Y-%m-%d") , units="days")
df_rho <- df_rho %>% filter( df_rho$time >= 0)
ggplot(df_gonot_out) +
geom_line(aes(date,gono)) +
ggtitle("Gonotrophic cycle")+
theme_bw()
ggplot(df_dL_out) +
geom_line(aes(date,dL)) +
ggtitle("Larva development rate")+
theme_bw()
ggplot(df_gonot_out) +
geom_line(aes(date,gono)) +
ggtitle("Gonotrophic cycle")+
theme_bw()
ggplot(df_dL_out) +
geom_line(aes(date,dL)) +
ggtitle("Larva development rate")+
theme_bw()
ggplot(df_deltaL_out) +
geom_line(aes(date,deltaL)) +
ggtitle("Larva mortality rate")+
theme_bw()
ggplot(df_deltaA_out) +
geom_line(aes(date,deltaA)) +
ggtitle("Adult mosquito mortality rate")+
theme_bw()
df_gonot_out$date <- NULL
df_gonot_out <- df_gonot_out[,c(2,1)]
head(df_gonot_out)
df_dL_out$date <- NULL
df_dL_out <- df_dL_out[,c(2,1)]
head(df_dL_out)
df_deltaL_out$date <- NULL
df_deltaL_out <- df_deltaL_out[,c(2,1)]
head(df_deltaL_out)
df_deltaA_out$date <- NULL
df_deltaA_out <- df_deltaA_out[,c(2,1)]
head(df_deltaA_out)
df_rho$date <- NULL
df_rho <- df_rho[,c(2,1)]
head(df_rho)
###############   ODE INTEGRATION   ##################
# require(deSolve)
# library.dynam.unload("deSolve", libpath=paste(.libPaths()[1], "//deSolve", sep=""))
# library.dynam("deSolve", package="deSolve", lib.loc=.libPaths()[1])
# OJOOOOO!!! Cuando cambias de PC borrar .o y .so.
Path = "~/MAD_MODEL/VECTOR_MODEL/Code/PARAM_ESTIMA/"
head(df_deltaA_out)
###############   ODE INTEGRATION   ##################
# require(deSolve)
# library.dynam.unload("deSolve", libpath=paste(.libPaths()[1], "//deSolve", sep=""))
# library.dynam("deSolve", package="deSolve", lib.loc=.libPaths()[1])
# OJOOOOO!!! Cuando cambias de PC borrar .o y .so.
Path = "~/MAD_MODEL/VECTOR_MODEL/Code/PARAM_ESTIMA/"
setwd(Path)
system("R CMD SHLIB model.c")
dyn.load("model.so")
f = 200
K = 250000
H = 160000
omega_t = 0.2
trueSD = 1
# We create a vector with the constant parameters.
parms = c(f,K,H, omega_t)
# We set the initial conditions to cero.
Y <- c(y1 = 100.0, y2 = 0.0, y3 = 0.0)
# List with the data frames of the forcings, sort as the c code.
forcs_mat <- list(data.matrix(df_gonot_out),
data.matrix(df_dL_out),
data.matrix(df_deltaL_out),
data.matrix(df_deltaA_out))
min_t <- min(df_dL_out$time)
max_t <- max(df_gonot_out$time)
times <- seq(min_t,max_t, 1)
out <- ode(Y, times, func = "derivs",
parms = parms, dllname = "model",
initfunc = "initmod", nout = 1,
outnames = "Sum", initforc = "forcc",
forcings = forcs_mat, fcontrol = list(method = "constant"))
ode <- data.frame(out)
saveRDS(ode, file = "~/MAD_MODEL/VECTOR_MODEL/Code/PARAM_ESTIMA/ode_pseudo.rds")
likelihood <- function(x) # forzamientos para el solver de la ode
{
if(x[1] <= 0 ){
print("Negative param")
res = -86829146000
}else{
pars <- c(f = f,K = K,H = H,omega = x[1]) # death rate group 2
sd <- x[2]
population <- c(y1 = 100.0, y2 = 0.0, y3 = 0.0) #Vector inicial para ODE
z <- ode(y=population,
times = 0:nrow(y), func = "derivs", method = "ode45",
dllname = "model" , parms = pars,
initfunc = "initmod", initforc = "forcc",
forcings = forcs_mat, fcontrol = list(method = "constant"))
#Aquí corre el ODE
colnames(z)[2:4] <- c("L", "A", "Ah")
z <- as.data.frame(z)
z <- z[-1, ]
L <- y$L
A <- y$A
Ah <- y$Ah
res <- #cálculo de la loglikelihood en función de las desviaciones estándar
sum(dnorm((A+Ah), mean = (z$A + z$Ah), sd = sd, log = T))
}
# print("res:")
# print(res)
return(res)
}
# Pseudo Data to check the oprimization method.
ob_data <- readRDS(file = "~/MAD_MODEL/VECTOR_MODEL/Code/PARAM_ESTIMA/ode_pseudo.rds")
colnames(ob_data) <- c("time", "L", "A", "Ah")
l <- nrow(ob_data)
ob_data$L <- ob_data$L + rnorm(l,0,trueSD)
ob_data$A <- ob_data$A + rnorm(l,0,trueSD)
ob_data$Ah <- ob_data$Ah + rnorm(l,0,trueSD)
true1 = omega_t
y <- ob_data
# Prior distribution
prior = function(param){
a = param[1]
sd = param[2]
aprior = dnorm(a, sd=1,  log = T)
sdprior = dnorm(sd, sd=1,  log = T)
return(aprior+sdprior)
}
proposalfunction = function(param){
vec <- c(rnorm(1, mean = param[1], sd= 0.1)
,abs(rnorm(1,mean = param[2] ,sd = 0.1)))
return(vec)
}
run_metropolis_MCMC = function(startvalue, iterations){
chain = array(dim = c(iterations+1,2))
chain[1,] = startvalue
for (i in 1:iterations){
proposal = proposalfunction(chain[i,])
print("Iteration:")
print(i)
print("likelihood(proposal):")
print(likelihood(proposal))
print("prior(proposal):")
print(prior(proposal))
print("likelihood(chain[i,]):")
print(likelihood(chain[i,]))
probab = exp(likelihood(proposal)+ prior(proposal) - likelihood(chain[i,])- prior(chain[i,]))
if (runif(1) < probab){
chain[i+1,] = proposal
}else{
chain[i+1,] = chain[i,] }
}
return(chain)
}
startvalue = c(0.1,1)
iterations = 1000
chain = run_metropolis_MCMC(startvalue, iterations)
rm(list = ls())
library("parallel")
library("tidyverse")
library("deSolve")
library("coda")
# True param:
gam1 = 0.2
gam2 = 1.2
gam3 = 3
true1 = gam1
true2 = gam2
true3 = gam3
trueSD = 1
# Easy plots:
output <- load("~/Documents/PHD/2021/SUR_Model/PARAM_ESTIMATION/MH/Output/chain_MH_100eq10000.RData")
burnIn = 5000
acceptance = 1-mean(duplicated(chain[-(1:burnIn),]))
par(mfrow = c(2,4))
hist(chain[-(1:burnIn),1],nclass=30, main="Posterior of a", xlab="True value = red line" )
abline(v = mean(chain[-(1:burnIn),1]))
burnIn = 5000
acceptance = 1-mean(duplicated(chain[-(1:burnIn),]))
par(mfrow = c(2,4))
hist(chain[-(1:burnIn),1],nclass=30, main="Posterior of a", xlab="True value = red line" )
abline(v = mean(chain[-(1:burnIn),1]))
abline(v = true1, col="red" )
hist(chain[-(1:burnIn),2],nclass=30, main="Posterior of b", xlab="True value = red line")
abline(v = mean(chain[-(1:burnIn),2]))
abline(v = true2, col="red" )
hist(chain[-(1:burnIn),3],nclass=30, main="Posterior of c", xlab="True value = red line")
abline(v = mean(chain[-(1:burnIn),3]))#
abline(v = true3, col="red" )
hist(chain[-(1:burnIn),4],nclass=30, main="Posterior of sd", xlab="True value = red line")
abline(v = mean(chain[-(1:burnIn),4]) )
abline(v = trueSD, col="red" )
plot(chain[-(1:burnIn),1], type = "l", xlab="True value = red line" , main = "Chain values of a", )
abline(h = true1, col="red" )
plot(chain[-(1:burnIn),2], type = "l", xlab="True value = red line" , main = "Chain values of b", )
abline(h = true2, col="red" )
plot(chain[-(1:burnIn),3], type = "l", xlab="True value = red line" , main = "Chain values of c", )
burnIn = 500
acceptance = 1-mean(duplicated(chain[-(1:burnIn),]))
par(mfrow = c(2,4))
hist(chain[-(1:burnIn),1],nclass=30, main="Posterior of a", xlab="True value = red line" )
abline(v = mean(chain[-(1:burnIn),1]))
abline(v = true1, col="red" )
hist(chain[-(1:burnIn),2],nclass=30, main="Posterior of b", xlab="True value = red line")
abline(v = mean(chain[-(1:burnIn),2]))
abline(v = true2, col="red" )
hist(chain[-(1:burnIn),3],nclass=30, main="Posterior of c", xlab="True value = red line")
abline(v = mean(chain[-(1:burnIn),3]))#
abline(v = true3, col="red" )
hist(chain[-(1:burnIn),4],nclass=30, main="Posterior of sd", xlab="True value = red line")
abline(v = mean(chain[-(1:burnIn),4]) )
abline(v = trueSD, col="red" )
plot(chain[-(1:burnIn),1], type = "l", xlab="True value = red line" , main = "Chain values of a", )
abline(h = true1, col="red" )
plot(chain[-(1:burnIn),2], type = "l", xlab="True value = red line" , main = "Chain values of b", )
abline(h = true2, col="red" )
plot(chain[-(1:burnIn),3], type = "l", xlab="True value = red line" , main = "Chain values of c", )
abline(h = true3, col="red" )
plot(chain[-(1:burnIn),3], type = "l", xlab="True value = red line" , main = "Chain values of sd", )
abline(h = trueSD, col="red" )
# Plots from coda package:
output <- load("~/Documents/PHD/2021/SUR_Model/PARAM_ESTIMATION/MH/Output/chain_MH_op_4eq_3param1e+05.RData")
chain_mc <- mcmc(chain)
summary(chain_mc)
plot(chain_mc)
pairs(chain_mc)
debugSource('~/MAD_MODEL/VECTOR_MODEL/Code/PARAM_ESTIMA/MH.R')
debugSource('~/MAD_MODEL/VECTOR_MODEL/Code/PARAM_ESTIMA/MH.R')
rm(list = ls())
library("parallel")
library("tidyverse")
library("deSolve")
library("coda")
Path = "~/MAD_MODEL/VECTOR_MODEL/data/df_rho.dat"
df_rho <- data.frame(t(read.table(Path, header=FALSE)))
colnames(df_rho) <- c("time", "rho", "date")
df_rho$date = as.Date(df_rho$date , "%Y-%m-%d")
df_rho$time <- NULL
df_rho$rho <- as.numeric(df_rho$rho)
ggplot(df_rho) +
geom_line(aes(x = date, y =rho)) +
ggtitle("Encounter rate computed from Citizen Science model") +
theme_bw()
# Temperatures from Barcelona:
Path_temp = "~/MAD_MODEL/VECTOR_MODEL/data/bcn_weather_daily.Rds"
temp <-read_rds(Path_temp)
temp$date = as.Date(temp$date , "%Y-%m-%d")
temp <- temp %>%  group_by(date) %>% summarise(mean_temp = mean(valor))
ggplot(temp) +
geom_line(aes(date, mean_temp))+
ggtitle("Mean temperature Barcelona") +
xlab("Mean temperature")+
theme_bw()
# Gonotrophic cycle:
gonot <- function(T){
val = (0.045*T^2 - 2.717*T + 44.405)^(-1)
return(val)
}
# Development rate
d_L <- function(T){
sigma <- (0.14457*T^2 - 8.24857*T + 124.80857)^(-1)
return(sigma)
}
# Larva mortality rate
delta_L <- function(T){
rate <- 0.021643*T^2 - 0.959568*T + 10.440131
if (rate < 0) {
rate <- 0 }
return(rate)
}
# Adult mosquito mortality rate
delta_A <- function(T){
if (T <=20) {
rate <- - 0.01019105*T^3 + 0.5920223*T^2 - 11.38171*T + 72.60858
#rate <- 0
} else if (T>20 & T<=25) {
rate <- 0.001216109*T^3 - 0.09240726*T^2 + 2.306881*T - 18.6487 #rate <- 0
} else if (T>25 & T<=30) {
rate <- 0.002551257*T^3 - 0.1925433*T^2 + 4.810282*T - 39.51037
} else
rate <- 0.01310967*T^3 - 1.142801*T^2 + 33.31801*T - 324.5876
return(rate)
}
vec = seq(0,40,1)
df_gonot_vec <- data.frame(temp = vec, gonot =unlist(lapply(vec,gonot)))
df_dL_vec <- data.frame(temp = vec, dL = unlist(lapply(vec,d_L)))
df_deltaL_vec <- data.frame(temp = vec, deltaL = unlist(lapply(vec,delta_L)))
df_deltaA_vec <- data.frame(temp = vec, deltaA = unlist(lapply(vec,delta_A)))
ggplot(df_gonot_vec) + geom_line(aes(temp,gonot)) +
ggtitle("Inverse of the Gonotrophic cycle")+
theme_bw()
ggplot(df_dL_vec) + geom_line(aes(temp,dL)) +
ggtitle("Larva development rate")+
theme_bw()
ggplot(df_deltaL_vec) + geom_line(aes(temp,deltaL)) +
ggtitle("Larva mortality rate")+
theme_bw()
ggplot(df_deltaA_vec) + geom_line(aes(temp,deltaA)) +
ggtitle("Mosquito adult mortality rate")+
theme_bw()
# Compute the values of the functions/forcings with temp.
# Compute the minimum date of the rho:
min_date <- min(temp$date)
max_date <- max(temp$date)
# DFs with the date and value of the parameter at that time.
temp <- temp  %>% filter( temp$date >= min_date & temp$date <= max_date)
df_date <- data.frame(date = temp$date)
df_date$time = as.numeric(df_date$date - as.Date(min_date,"%Y-%m-%d") , units="days")
gono = unlist(lapply(temp$mean_temp,gonot))
df_gonot_out <- data.frame(date = temp$date, gono)
df_gonot_out$time = as.numeric(df_gonot_out$date - as.Date(min_date,"%Y-%m-%d") , units="days")
df_gonot_out <- df_gonot_out %>% filter( df_gonot_out$time >= 0)
df_dL_out <- data.frame(date = temp$date, dL = unlist(lapply(temp$mean_temp,d_L)))
df_dL_out$time = as.numeric(df_dL_out$date - as.Date(min_date,"%Y-%m-%d") , units="days")
df_dL_out <- df_dL_out %>% filter( df_dL_out$time >= 0)
df_deltaL_out <- data.frame(date = temp$date, deltaL = unlist(lapply(temp$mean_temp,delta_L)))
df_deltaL_out$time = as.numeric(df_deltaL_out$date - as.Date(min_date,"%Y-%m-%d") , units="days")
df_deltaL_out <- df_deltaL_out %>% filter( df_deltaL_out$time >= 0)
df_deltaA_out <- data.frame(date = temp$date, deltaA = unlist(lapply(temp$mean_temp,delta_A)))
df_deltaA_out$time = as.numeric(df_deltaA_out$date - as.Date(min_date,"%Y-%m-%d") , units="days")
df_deltaA_out <- df_deltaA_out %>% filter( df_deltaA_out$time >= 0)
ggplot(df_gonot_out) +
geom_line(aes(date,gono)) +
ggtitle("Gonotrophic cycle")+
theme_bw()
ggplot(df_dL_out) +
geom_line(aes(date,dL)) +
ggtitle("Larva development rate")+
theme_bw()
ggplot(df_deltaL_out) +
geom_line(aes(date,deltaL)) +
ggtitle("Larva mortality rate")+
theme_bw()
ggplot(df_deltaA_out) +
geom_line(aes(date,deltaA)) +
ggtitle("Adult mosquito mortality rate")+
theme_bw()
df_gonot_out$date <- NULL
df_gonot_out <- df_gonot_out[,c(2,1)]
head(df_gonot_out)
df_dL_out$date <- NULL
df_dL_out <- df_dL_out[,c(2,1)]
head(df_dL_out)
df_deltaL_out$date <- NULL
df_deltaL_out <- df_deltaL_out[,c(2,1)]
head(df_deltaL_out)
df_deltaA_out$date <- NULL
df_deltaA_out <- df_deltaA_out[,c(2,1)]
head(df_deltaA_out)
###############   ODE INTEGRATION   ##################
# require(deSolve)
# library.dynam.unload("deSolve", libpath=paste(.libPaths()[1], "//deSolve", sep=""))
# library.dynam("deSolve", package="deSolve", lib.loc=.libPaths()[1])
# OJOOOOO!!! Cuando cambias de PC borrar .o y .so.
Path = "~/MAD_MODEL/VECTOR_MODEL/Code/PARAM_ESTIMA/"
setwd(Path)
system("R CMD SHLIB model.c")
dyn.load("model.so")
f = 200
K = 250000
H = 160000
omega_t = 0.2
trueSD = 1
# We create a vector with the constant parameters.
parms = c(f,K,H, omega_t)
# We set the initial conditions to cero.
Y <- c(y1 = 100.0, y2 = 0.0, y3 = 0.0)
# List with the data frames of the forcings, sort as the c code.
forcs_mat <- list(data.matrix(df_gonot_out),
data.matrix(df_dL_out),
data.matrix(df_deltaL_out),
data.matrix(df_deltaA_out))
min_t <- min(df_dL_out$time)
max_t <- max(df_gonot_out$time)
times <- seq(min_t,max_t, 1)
out <- ode(Y, times, func = "derivs",
parms = parms, dllname = "model",
initfunc = "initmod", nout = 1,
outnames = "Sum", initforc = "forcc",
forcings = forcs_mat, fcontrol = list(method = "constant"))
ode <- data.frame(out)
ode
View(ode)
View(ode)
min_t <- min(df_dL_out$time)
max_t <- max(df_dL_out$time)
times <- seq(min_t,max_t, 1)
out <- ode(Y, times, func = "derivs",
parms = parms, dllname = "model",
initfunc = "initmod", nout = 1,
outnames = "Sum", initforc = "forcc",
forcings = forcs_mat, fcontrol = list(method = "constant"))
ode <- data.frame(out)
min_t
max_t
View(df_deltaA_vec)
View(df_deltaA_out)
View(df_deltaL_out)
likelihood <- function(x) # forzamientos para el solver de la ode
{
if(x[1] <= 0 ){
print("Negative param")
res = -86829146000
}else{
pars <- c(f = f,K = K,H = H,omega = x[1]) # death rate group 2
sd <- x[2]
population <- c(y1 = 100.0, y2 = 0.0, y3 = 0.0) #Vector inicial para ODE
z <- ode(y=population,
times = 0:nrow(y), func = "derivs", method = "ode45",
dllname = "model" , parms = pars,
initfunc = "initmod", initforc = "forcc",
forcings = forcs_mat, fcontrol = list(method = "constant"))
#Aquí corre el ODE
colnames(z)[2:4] <- c("L", "A", "Ah")
z <- as.data.frame(z)
z <- z[-1, ]
L <- y$L
A <- y$A
Ah <- y$Ah
res <- #cálculo de la loglikelihood en función de las desviaciones estándar
sum(dnorm((A+Ah), mean = (z$A + z$Ah), sd = sd, log = T))
}
# print("res:")
# print(res)
return(res)
}
# Pseudo Data to check the oprimization method.
ob_data <- readRDS(file = "~/MAD_MODEL/VECTOR_MODEL/Code/PARAM_ESTIMA/ode_pseudo.rds")
colnames(ob_data) <- c("time", "L", "A", "Ah")
View(ob_data)
View(ob_data)
ode$Sum <- NULL
saveRDS(ode, file = "~/MAD_MODEL/VECTOR_MODEL/Code/PARAM_ESTIMA/ode_pseudo.rds")
likelihood <- function(x) # forzamientos para el solver de la ode
{
if(x[1] <= 0 ){
print("Negative param")
res = -86829146000
}else{
pars <- c(f = f,K = K,H = H,omega = x[1]) # death rate group 2
sd <- x[2]
population <- c(y1 = 100.0, y2 = 0.0, y3 = 0.0) #Vector inicial para ODE
z <- ode(y=population,
times = 0:nrow(y), func = "derivs", method = "ode45",
dllname = "model" , parms = pars,
initfunc = "initmod", initforc = "forcc",
forcings = forcs_mat, fcontrol = list(method = "constant"))
#Aquí corre el ODE
colnames(z)[2:4] <- c("L", "A", "Ah")
z <- as.data.frame(z)
z <- z[-1, ]
L <- y$L
A <- y$A
Ah <- y$Ah
res <- #cálculo de la loglikelihood en función de las desviaciones estándar
sum(dnorm((A+Ah), mean = (z$A + z$Ah), sd = sd, log = T))
}
# print("res:")
# print(res)
return(res)
}
# Pseudo Data to check the oprimization method.
ob_data <- readRDS(file = "~/MAD_MODEL/VECTOR_MODEL/Code/PARAM_ESTIMA/ode_pseudo.rds")
colnames(ob_data) <- c("time", "L", "A", "Ah")
l <- nrow(ob_data)
ob_data$L <- ob_data$L + rnorm(l,0,trueSD)
ob_data$A <- ob_data$A + rnorm(l,0,trueSD)
ob_data$Ah <- ob_data$Ah + rnorm(l,0,trueSD)
true1 = omega_t
View(ob_data)
View(ob_data)
y <- ob_data
# Prior distribution
prior = function(param){
a = param[1]
sd = param[2]
aprior = dnorm(a, sd=1,  log = T)
sdprior = dnorm(sd, sd=1,  log = T)
return(aprior+sdprior)
}
proposalfunction = function(param){
vec <- c(rnorm(1, mean = param[1], sd= 0.1)
,abs(rnorm(1,mean = param[2] ,sd = 0.1)))
return(vec)
}
run_metropolis_MCMC = function(startvalue, iterations){
chain = array(dim = c(iterations+1,2))
chain[1,] = startvalue
for (i in 1:iterations){
proposal = proposalfunction(chain[i,])
print("Iteration:")
print(i)
print("likelihood(proposal):")
print(likelihood(proposal))
print("prior(proposal):")
print(prior(proposal))
print("likelihood(chain[i,]):")
print(likelihood(chain[i,]))
probab = exp(likelihood(proposal)+ prior(proposal) - likelihood(chain[i,])- prior(chain[i,]))
if (runif(1) < probab){
chain[i+1,] = proposal
}else{
chain[i+1,] = chain[i,] }
}
return(chain)
}
startvalue = c(0.1,1)
iterations = 1000
chain = run_metropolis_MCMC(startvalue, iterations)
debugSource('~/MAD_MODEL/VECTOR_MODEL/Code/PARAM_ESTIMA/MH.R')
debugSource('~/MAD_MODEL/VECTOR_MODEL/Code/PARAM_ESTIMA/MH.R')
