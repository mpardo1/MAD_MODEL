# initfunc = "initmod", nout = 1,
# outnames = "Sum")
z <- ode(y = population, times = 0:nrow(y), func = vect, parms = pars)
#Aquí corre el ODE
colnames(z)[2:4] <- c("L", "A", "Ah")
z <- as.data.frame(z)
z <- z[-1, ]
L <- y$L
A <- y$A
Ah <- y$Ah
res <-  sum(dnorm(L, mean = z$L, sd = sd_t, log = T))  +
sum(dnorm(A, mean = z$A , sd = sd_t, log = T))  +
sum(dnorm(Ah, mean = z$Ah, sd = sd_t, log = T))  #cálculo de la loglikelihood en función de las desviaciones estándar
# sum(dnorm((A+Ah), mean = (z$A + z$Ah), sd = sd, log = T))
}
# print("res:")
# print(res)
return(res)
}
# Pseudo Data to check the oprimization method.
ob_data <- readRDS(file = "~/MAD_MODEL/VECTOR_MODEL/Code/PARAM_ESTIMA/ode_pseudo_cte.rds")
colnames(ob_data) <- c("time", "L", "A", "Ah")
l <- nrow(ob_data)
true1 = omega_t
y <- ob_data
slopevalues = function(x){return(likelihood(c(x, trueSD)))}
slopevalues(0.1)
x <- seq(0.01, 10, by=.05)
slopelikelihoods = lapply(x, slopevalues )
plot (x, slopelikelihoods , type="l", xlab = "values of slope parameter a", ylab = "Log likelihood")
x <- seq(-1, 10, by=.05)
slopelikelihoods = lapply(x, slopevalues )
plot (x, slopelikelihoods , type="l", xlab = "values of slope parameter a", ylab = "Log likelihood")
rm(list = ls())
library("parallel")
library("tidyverse")
library("deSolve")
library("coda")
#-------------------------------FUNCTIONS--------------------------------------#
# Equilibrium points:
eq_point <- function(delta_L, delta_A, d_L, a, fec, K, Hum, omega_t){
Ah_eq <-  K*(((omega_t*Hum*d_L)/((a+delta_A)*(omega_t*Hum +delta_A)))-((1/(a*fec))*(d_L+delta_L)))
L_eq <- ((a*fec*Ah_eq)/((a*fec/K)*Ah_eq+(d_L+delta_L)))
A_eq <- ((d_L/(omega_t*Hum+delta_A))*((a*fec*Ah_eq)/(((a*fec/K)*Ah_eq)+(d_L+delta_L))))
eq <- c(L_eq, A_eq, Ah_eq)
}
ode_value <- function(L, A, Ah){
val <- c()
val[1] = a*fec*Ah*(1-(L/K))-(d_L+delta_L)*L
val[2] = d_L*L - (omega_t*Hum + delta_A)*A
val[3] = omega_t*Hum*A - (a + delta_A)*Ah
return(val)
}
# Feasability condition:
feasability_cond <- function(del_L, del_A, dev_L, gon, fec, Kar, Hum, omega){
fes <- FALSE
val <- (gon*fec*omega*Hum*dev_L)/((gon + del_A)*(omega*Hum + del_A)*(dev_L + del_L))
if(val > 1){
fes <- TRUE
}
return(fes)
}
###############   ODE INTEGRATION   ##################
#------------------------------------------------------------------------------#
# ODE system in R:
vect <- function(t, state, parameters) {
with(as.list(c(state, parameters)),{
# rate of change
dL <-  gon*fecun*H*(1-(L/Ka))-(dev_L+del_L)*L
dA <-  dev_L*L - (omeg*Hu + del_A)*A
dH <-  omeg*Hu*A - (gon + del_A)*H
# return the rate of change
list(c(dL, dA, dH))
}) # end with(as.list ...
}
likelihood <- function(x) # forzamientos para el solver de la ode
{
if(x[1] <= 0 ){
print("Negative param")
res = -86829146000
}else{
# print("Positive param")
pars <- c(fecun = fec,Ka = K,Hu = Hum,omeg = x[1],
del_L = delta_L,del_A = delta_A,dev_L = d_L,
gon = a) # death rate group 2
sd_t <- x[2]
population <- c(L=10.0, A=0.0,H= 0.0) #Vector inicial para ODE
# z <- ode(y=population,
# times = 0:nrow(y), func = "derivs", method = "ode45",
# parms = parms, dllname = "model_vec_test1",
# initfunc = "initmod", nout = 1,
# outnames = "Sum")
z <- ode(y = population, times = 0:nrow(y), func = vect, parms = pars)
#Aquí corre el ODE
colnames(z)[2:4] <- c("L", "A", "Ah")
z <- as.data.frame(z)
z <- z[-1, ]
L <- y$L
A <- y$A
Ah <- y$Ah
res <-  sum(dnorm(L, mean = z$L, sd = sd_t, log = T))  +
sum(dnorm(A, mean = z$A , sd = sd_t, log = T))  +
sum(dnorm(Ah, mean = z$Ah, sd = sd_t, log = T))  #cálculo de la loglikelihood en función de las desviaciones estándar
# sum(dnorm((A+Ah), mean = (z$A + z$Ah), sd = sd, log = T))
}
# print("res:")
# print(res)
return(res)
}
#------------------------------------------------------------------------------#
# Params values:
fec = 2000
K = 43000
Hum = 13554
omega_t = 0.2
delta_L = 0.2
delta_A = 0.3
d_L = 8
a = 0.01
feasability_cond(delta_L,delta_A,d_L,a,fec ,K,Hum,omega_t)
vec_eq <- eq_point(delta_L, delta_A, d_L, a, fec, K, Hum, omega_t)
stab_cond = function(x){return(feasability_cond(c(delta_L,delta_A,d_L,a,fec ,K,Hum,x)))}
eq_point = function(x){return(vec_eq(c(delta_L, delta_A, d_L, a, fec, K, Hum, x)))}
x <- seq(0, 10, by=.05)
stab_cond_vec <- lapply(x, stab_cond )
feasability_cond(delta_L,delta_A,d_L,a,fec ,K,Hum,omega_t)
vec_eq <- eq_point(delta_L, delta_A, d_L, a, fec, K, Hum, omega_t)
#-------------------------------FUNCTIONS--------------------------------------#
# Equilibrium points:
eq_po <- function(delta_L, delta_A, d_L, a, fec, K, Hum, omega_t){
Ah_eq <-  K*(((omega_t*Hum*d_L)/((a+delta_A)*(omega_t*Hum +delta_A)))-((1/(a*fec))*(d_L+delta_L)))
L_eq <- ((a*fec*Ah_eq)/((a*fec/K)*Ah_eq+(d_L+delta_L)))
A_eq <- ((d_L/(omega_t*Hum+delta_A))*((a*fec*Ah_eq)/(((a*fec/K)*Ah_eq)+(d_L+delta_L))))
eq <- c(L_eq, A_eq, Ah_eq)
}
rm(list = ls())
library("parallel")
library("tidyverse")
library("deSolve")
library("coda")
#-------------------------------FUNCTIONS--------------------------------------#
# Equilibrium points:
eq_point <- function(delta_L, delta_A, d_L, a, fec, K, Hum, omega_t){
Ah_eq <-  K*(((omega_t*Hum*d_L)/((a+delta_A)*(omega_t*Hum +delta_A)))-((1/(a*fec))*(d_L+delta_L)))
L_eq <- ((a*fec*Ah_eq)/((a*fec/K)*Ah_eq+(d_L+delta_L)))
A_eq <- ((d_L/(omega_t*Hum+delta_A))*((a*fec*Ah_eq)/(((a*fec/K)*Ah_eq)+(d_L+delta_L))))
eq <- c(L_eq, A_eq, Ah_eq)
}
ode_value <- function(L, A, Ah){
val <- c()
val[1] = a*fec*Ah*(1-(L/K))-(d_L+delta_L)*L
val[2] = d_L*L - (omega_t*Hum + delta_A)*A
val[3] = omega_t*Hum*A - (a + delta_A)*Ah
return(val)
}
# Feasability condition:
feasability_cond <- function(del_L, del_A, dev_L, gon, fec, Kar, Hum, omega){
fes <- FALSE
val <- (gon*fec*omega*Hum*dev_L)/((gon + del_A)*(omega*Hum + del_A)*(dev_L + del_L))
if(val > 1){
fes <- TRUE
}
return(fes)
}
###############   ODE INTEGRATION   ##################
#------------------------------------------------------------------------------#
# ODE system in R:
vect <- function(t, state, parameters) {
with(as.list(c(state, parameters)),{
# rate of change
dL <-  gon*fecun*H*(1-(L/Ka))-(dev_L+del_L)*L
dA <-  dev_L*L - (omeg*Hu + del_A)*A
dH <-  omeg*Hu*A - (gon + del_A)*H
# return the rate of change
list(c(dL, dA, dH))
}) # end with(as.list ...
}
likelihood <- function(x) # forzamientos para el solver de la ode
{
if(x[1] <= 0 ){
print("Negative param")
res = -86829146000
}else{
# print("Positive param")
pars <- c(fecun = fec,Ka = K,Hu = Hum,omeg = x[1],
del_L = delta_L,del_A = delta_A,dev_L = d_L,
gon = a) # death rate group 2
sd_t <- x[2]
population <- c(L=10.0, A=0.0,H= 0.0) #Vector inicial para ODE
# z <- ode(y=population,
# times = 0:nrow(y), func = "derivs", method = "ode45",
# parms = parms, dllname = "model_vec_test1",
# initfunc = "initmod", nout = 1,
# outnames = "Sum")
z <- ode(y = population, times = 0:nrow(y), func = vect, parms = pars)
#Aquí corre el ODE
colnames(z)[2:4] <- c("L", "A", "Ah")
z <- as.data.frame(z)
z <- z[-1, ]
L <- y$L
A <- y$A
Ah <- y$Ah
res <-  sum(dnorm(L, mean = z$L, sd = sd_t, log = T))  +
sum(dnorm(A, mean = z$A , sd = sd_t, log = T))  +
sum(dnorm(Ah, mean = z$Ah, sd = sd_t, log = T))  #cálculo de la loglikelihood en función de las desviaciones estándar
# sum(dnorm((A+Ah), mean = (z$A + z$Ah), sd = sd, log = T))
}
# print("res:")
# print(res)
return(res)
}
#------------------------------------------------------------------------------#
# Params values:
fec = 2000
K = 43000
Hum = 13554
omega_t = 0.2
delta_L = 0.2
delta_A = 0.3
d_L = 8
a = 0.01
feasability_cond(delta_L,delta_A,d_L,a,fec ,K,Hum,omega_t)
vec_eq <- eq_point(delta_L, delta_A, d_L, a, fec, K, Hum, omega_t)
stab_cond = function(x){return(feasability_cond(c(del_L,del_A,dev_L,gon,fec ,K,Hum,x)))}
eq_point = function(x){return(vec_eq(c(delta_L, del_A, d_L, gon, fec, K, Hum, x)))}
x <- seq(0, 10, by=.05)
stab_cond_vec <- lapply(x, stab_cond )
stab_cond = function(x){return(feasability_cond(c(delta_L,delta_A,d_L,a,fec ,K,Hum,x)))}
eq_point = function(x){return(vec_eq(c(delta_L, delta_A, d_L, a, fec, K, Hum, x)))}
x <- seq(0, 10, by=.05)
stab_cond_vec <- lapply(x, stab_cond )
stab_cond = function(x){return(feasability_cond(delta_L,delta_A,d_L,a,fec ,K,Hum,x))}
eq_point = function(x){return(vec_eq(delta_L, delta_A, d_L, a, fec, K, Hum, x))}
x <- seq(0, 10, by=.05)
stab_cond_vec <- lapply(x, stab_cond )
eq_point_vec <- lapply(x, eq_point )
eq_point = function(x){return(eq_point(delta_L, delta_A, d_L, a, fec, K, Hum, x))}
x <- seq(0, 10, by=.05)
stab_cond_vec <- lapply(x, stab_cond )
eq_point_vec <- lapply(x, eq_point )
View(stab_cond_vec)
View(stab_cond_vec)
stab_cond_vec <- data.frame(x <- x, stab = lapply(x, stab_cond))
plot(stab_cond_vec)
View(stab_cond_vec)
View(stab_cond_vec)
stab_cond_vec <- data.frame(x <- x, stab = t(lapply(x, stab_cond)))
plot(stab_cond_vec)
View(stab_cond_vec)
View(stab_cond_vec)
t(lapply(x, stab_cond))
rm(list = ls())
library("parallel")
library("tidyverse")
library("deSolve")
library("coda")
#-------------------------------FUNCTIONS--------------------------------------#
# Equilibrium points:
eq_point <- function(delta_L, delta_A, d_L, a, fec, K, Hum, omega_t){
Ah_eq <-  K*(((omega_t*Hum*d_L)/((a+delta_A)*(omega_t*Hum +delta_A)))-((1/(a*fec))*(d_L+delta_L)))
L_eq <- ((a*fec*Ah_eq)/((a*fec/K)*Ah_eq+(d_L+delta_L)))
A_eq <- ((d_L/(omega_t*Hum+delta_A))*((a*fec*Ah_eq)/(((a*fec/K)*Ah_eq)+(d_L+delta_L))))
eq <- c(L_eq, A_eq, Ah_eq)
}
ode_value <- function(L, A, Ah){
val <- c()
val[1] = a*fec*Ah*(1-(L/K))-(d_L+delta_L)*L
val[2] = d_L*L - (omega_t*Hum + delta_A)*A
val[3] = omega_t*Hum*A - (a + delta_A)*Ah
return(val)
}
# Feasability condition:
feasability_cond <- function(del_L, del_A, dev_L, gon, fec, Kar, Hum, omega){
fes <- 0
val <- (gon*fec*omega*Hum*dev_L)/((gon + del_A)*(omega*Hum + del_A)*(dev_L + del_L))
if(val > 1){
fes <- 1
}
return(fes)
}
###############   ODE INTEGRATION   ##################
#------------------------------------------------------------------------------#
# ODE system in R:
vect <- function(t, state, parameters) {
with(as.list(c(state, parameters)),{
# rate of change
dL <-  gon*fecun*H*(1-(L/Ka))-(dev_L+del_L)*L
dA <-  dev_L*L - (omeg*Hu + del_A)*A
dH <-  omeg*Hu*A - (gon + del_A)*H
# return the rate of change
list(c(dL, dA, dH))
}) # end with(as.list ...
}
likelihood <- function(x) # forzamientos para el solver de la ode
{
if(x[1] <= 0 ){
print("Negative param")
res = -86829146000
}else{
# print("Positive param")
pars <- c(fecun = fec,Ka = K,Hu = Hum,omeg = x[1],
del_L = delta_L,del_A = delta_A,dev_L = d_L,
gon = a) # death rate group 2
sd_t <- x[2]
population <- c(L=10.0, A=0.0,H= 0.0) #Vector inicial para ODE
# z <- ode(y=population,
# times = 0:nrow(y), func = "derivs", method = "ode45",
# parms = parms, dllname = "model_vec_test1",
# initfunc = "initmod", nout = 1,
# outnames = "Sum")
z <- ode(y = population, times = 0:nrow(y), func = vect, parms = pars)
#Aquí corre el ODE
colnames(z)[2:4] <- c("L", "A", "Ah")
z <- as.data.frame(z)
z <- z[-1, ]
L <- y$L
A <- y$A
Ah <- y$Ah
res <-  sum(dnorm(L, mean = z$L, sd = sd_t, log = T))  +
sum(dnorm(A, mean = z$A , sd = sd_t, log = T))  +
sum(dnorm(Ah, mean = z$Ah, sd = sd_t, log = T))  #cálculo de la loglikelihood en función de las desviaciones estándar
# sum(dnorm((A+Ah), mean = (z$A + z$Ah), sd = sd, log = T))
}
# print("res:")
# print(res)
return(res)
}
#------------------------------------------------------------------------------#
# Params values:
fec = 2000
K = 43000
Hum = 13554
omega_t = 0.2
delta_L = 0.2
delta_A = 0.3
d_L = 8
a = 0.01
feasability_cond(delta_L,delta_A,d_L,a,fec ,K,Hum,omega_t)
vec_eq <- eq_point(delta_L, delta_A, d_L, a, fec, K, Hum, omega_t)
stab_cond = function(x){return(feasability_cond(delta_L,delta_A,d_L,a,fec ,K,Hum,x))}
eq_point = function(x){return(eq_point(delta_L, delta_A, d_L, a, fec, K, Hum, x))}
x <- seq(0, 10, by=.05)
stab_cond_vec <- data.frame(x <- x, stab = lapply(x, stab_cond))
View(stab_cond_vec)
View(stab_cond_vec)
stab_cond_vec <- data.frame(x <- x, stab = t(lapply(x, stab_cond)))
vec_stab <- lapply(x, stab_cond)
stab_cond_vec <- data.frame(x <- x, stab = t(as.array(vec_stab, nrow =1, ncol = length(x))))
stab_cond_vec <- data.frame(x <- x, stab = as.array(vec_stab, nrow =1, ncol = length(x)))
View(stab_cond_vec)
View(stab_cond_vec)
#------------------------------------------------------------------------------#
# Params values:
fec = 200
K = 43000
Hum = 13554
omega_t = 0.2
delta_L = 0.2
delta_A = 0.3
d_L = 8
a = 0.01
feasability_cond(delta_L,delta_A,d_L,a,fec ,K,Hum,omega_t)
vec_eq <- eq_point(delta_L, delta_A, d_L, a, fec, K, Hum, omega_t)
stab_cond = function(x){return(feasability_cond(delta_L,delta_A,d_L,a,fec ,K,Hum,x))}
eq_point = function(x){return(eq_point(delta_L, delta_A, d_L, a, fec, K, Hum, x))}
x <- seq(0, 10, by=.05)
vec_stab <- lapply(x, stab_cond)
stab_cond_vec <- data.frame(x <- x, stab = as.array(vec_stab, nrow =1, ncol = length(x)))
plot(stab_cond_vec)
#------------------------------------------------------------------------------#
# Params values:
fec = 200
K = 250000
Hum = 1600000
omega_t = 0.2
delta_L = 0.2
delta_A = 0.3
d_L = 8
a = 0.01
feasability_cond(delta_L,delta_A,d_L,a,fec ,K,Hum,omega_t)
vec_eq <- eq_point(delta_L, delta_A, d_L, a, fec, K, Hum, omega_t)
stab_cond = function(x){return(feasability_cond(delta_L,delta_A,d_L,a,fec ,K,Hum,x))}
eq_point = function(x){return(eq_point(delta_L, delta_A, d_L, a, fec, K, Hum, x))}
x <- seq(0, 10, by=.05)
vec_stab <- lapply(x, stab_cond)
stab_cond_vec <- data.frame(x <- x, stab = as.array(vec_stab, nrow =1, ncol = length(x)))
plot(stab_cond_vec)
#------------------------------------------------------------------------------#
# Params values:
fec = 200
K = 250000
Hum = 1600000
omega_t = 0.2
delta_L = 0.2
delta_A = 0.25
d_L = 0.08
a = 1/8
feasability_cond(delta_L,delta_A,d_L,a,fec ,K,Hum,omega_t)
vec_eq <- eq_point(delta_L, delta_A, d_L, a, fec, K, Hum, omega_t)
stab_cond = function(x){return(feasability_cond(delta_L,delta_A,d_L,a,fec ,K,Hum,x))}
eq_point = function(x){return(eq_point(delta_L, delta_A, d_L, a, fec, K, Hum, x))}
x <- seq(0, 10, by=.05)
vec_stab <- lapply(x, stab_cond)
stab_cond_vec <- data.frame(x <- x, stab = as.array(vec_stab, nrow =1, ncol = length(x)))
plot(stab_cond_vec)
eq_point_vec <- lapply(x, eq_point)
x <- seq(0, 1000, by=.05)
vec_stab <- lapply(x, stab_cond)
stab_cond_vec <- data.frame(x <- x, stab = as.array(vec_stab, nrow =1, ncol = length(x)))
plot(stab_cond_vec)
x <- seq(0, 100000, by=.05)
vec_stab <- lapply(x, stab_cond)
stab_cond_vec <- data.frame(x <- x, stab = as.array(vec_stab, nrow =1, ncol = length(x)))
plot(stab_cond_vec)
omega_stab <- function(omega){
fes <- 0
val <- delta_A/(((a*f*H*d_L)/((a+delta_A)*(d_L+delta_L)))-H)
if(omega > val ){
fes <- 1
}
return(fes)
}
val <- delta_A/(((a*f*H*d_L)/((a+delta_A)*(d_L+delta_L)))-H)
val <- delta_A/(((a*fec*H*d_L)/((a+delta_A)*(d_L+delta_L)))-H)
val <- delta_A/(((a*fec*Hum*d_L)/((a+delta_A)*(d_L+delta_L)))-Hum)
val
eq_point = function(x){return(eq_point(delta_L, delta_A, d_L, a, fec, K, Hum, x))}
x <- seq(0, 100, by=.05)
vec_stab <- lapply(x, stab_cond)
stab_cond_vec <- data.frame(x <- x, stab = as.array(vec_stab, nrow =1, ncol = length(x)))
plot(stab_cond_vec)
eq_point_vec <- lapply(x, eq_point)
n
#-------------------------------FUNCTIONS--------------------------------------#
# Equilibrium points:
eq_point <- function(delta_L, delta_A, d_L, a, fec, K, Hum, omega_t){
Ah_eq <-  K*(((omega_t*Hum*d_L)/((a+delta_A)*(omega_t*Hum +delta_A)))-((1/(a*fec))*(d_L+delta_L)))
L_eq <- ((a*fec*Ah_eq)/((a*fec/K)*Ah_eq+(d_L+delta_L)))
A_eq <- ((d_L/(omega_t*Hum+delta_A))*((a*fec*Ah_eq)/(((a*fec/K)*Ah_eq)+(d_L+delta_L))))
eq <- c(L_eq, A_eq, Ah_eq)
}
vec_eq <- eq_point(delta_L, delta_A, d_L, a, fec, K, Hum, omega_t)
vec_eq
eq_point = function(x){return(eq_point(delta_L, delta_A, d_L, a, fec, K, Hum, x))}
x <- seq(0, 100, by=.05)
eq_point_ap = function(x){return(eq_point(delta_L, delta_A, d_L, a, fec, K, Hum, x))}
#-------------------------------FUNCTIONS--------------------------------------#
# Equilibrium points:
eq_point <- function(delta_L, delta_A, d_L, a, fec, K, Hum, omega_t){
Ah_eq <-  K*(((omega_t*Hum*d_L)/((a+delta_A)*(omega_t*Hum +delta_A)))-((1/(a*fec))*(d_L+delta_L)))
L_eq <- ((a*fec*Ah_eq)/((a*fec/K)*Ah_eq+(d_L+delta_L)))
A_eq <- ((d_L/(omega_t*Hum+delta_A))*((a*fec*Ah_eq)/(((a*fec/K)*Ah_eq)+(d_L+delta_L))))
eq <- c(L_eq, A_eq, Ah_eq)
}
eq_point_ap = function(x){return(eq_point(delta_L, delta_A, d_L, a, fec, K, Hum, x))}
eq_point_vec <- lapply(x, eq_point_ap)
View(eq_point_vec)
View(eq_point_vec)
View(stab_cond_vec)
eq_point_vec <- lapply(x, eq_point_ap)
View(eq_point_vec)
View(eq_point_vec)
eq_point_df <- data.frame(x <- x, stab = as.array(eq_point_vec, nrow =1, ncol = length(x)))
plot(eq_point_df)
stab <- as.array(eq_point_vec, nrow =1, ncol = length(x))
View(stab)
View(stab)
eq_point_vec <- lapply(x, eq_point_ap)
stab <- as.array(eq_point_vec, nrow =1, ncol = length(x))
View(stab)
View(stab)
stab <- as.array(eq_point_vec$value, nrow =1, ncol = length(x))
eq_point_vec$value
View(eq_point_vec)
View(eq_point_vec)
stab <- unlist(eq_point_vec$value)
eq_point_vec <- lapply(x, eq_point_ap)
stab <- unlist(eq_point_vec$value)
stab <- as.numeric(eq_point_vec$value)
eq_point_vec <- lapply(x, eq_point_ap)
View(eq_point_vec)
View(eq_point_vec)
vec_stab <- lapply(x, stab_cond)
View(vec_stab)
View(vec_stab)
stab_cond_vec <- data.frame(x <- x, stab = as.array(vec_stab, nrow =1, ncol = length(x)))
View(stab_cond_vec)
# Equilibrium points as a function of omega.
eq_point_vec <- lapply(x, eq_point_ap)
stab <- as.array(eq_point_vec, nrow =3, ncol = length(x))
eq_point_df <- data.frame(omega = x, L_eq = stab[])
View(stab)
View(stab)
str(eq_point_vec)
eq_point_vec[[]]
eq_point_vec[[1]]
eq_point_vec[[:]]
eq_point_vec[[1:200]]
stab <- as.array(0, nrow =3, ncol = length(x))
length(x)
stab <- as.array(eq_point_vec)
View(stab)
View(stab)
eq_mat <- c()
class(eq_mat)
for(i in range(1:length(x))){
eq_mat[i] <- eq_point(delta_L, delta_A, d_L, a, fec, K, Hum, x[i])
}
eq_mat <- as.matrix(0, ncol = 3, nrow = length(x))
for(i in range(1:length(x))){
eq_mat[i] <- eq_point(delta_L, delta_A, d_L, a, fec, K, Hum, x[i])
}
